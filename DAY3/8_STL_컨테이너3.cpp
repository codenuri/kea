#include <iostream>
#include <vector>
#include <list>
#include <deque>

int main()
{
	std::vector<int> v = { 1,2,3,4,5 }; // 연속된 메모리, 삽입삭제 느리다. 
										// 요소 열거가 빠르고, 캐쉬 적중률이 높다.




	std::list<int>   s = { 1,2,3,4,5 }; // 모든 요소가 떨어진 메모리, 삽입삭제 빠르다.
										// 요소 열거가 느리고, 캐쉬 적중률이 낮다.
	



	std::deque<int>  d = { 1,2,3,4,5 }; // 연속된 메모리와 유사, 
										// 대부분의 작업에서 list 와 vector의 중간 성능
										// "덱" 또는 "디큐" 라고 발음합니다.
										// 
										// 
	// 핵심 1. 대부분의 멤버 함수는 이름이 동일합니다.
	// => 3개 컨테이너가 기능은 거의 동일하다는 의미
	// => 각 기능에 대한 성능이 다릅니다.
	// 열거      : vector가 빠르고
	// 삽입/삭제 : list 가 빠릅니다.
	v.push_back(1);
	s.push_back(1);
	d.push_back(1);
		


	// 핵심 2. 3개 컨테이너의 사용법이 유사하지만 다른경우가 있다면
	//         의도적인 설계 입니다.
	// => vector만 앞에 삽입할수 없습니다.
	// => 연속된 메모리의 전방삽입은 너무 느리므로 사용하지 말라는 의도
	s.push_front(10);
	d.push_front(10);
//	v.push_front(10); 



	// 핵심 3. [] 연산자는 vector와 deque만 가능합니다.(연속된 메모리와 유사한것만)
	v[0] = 0; // ok
	d[0] = 0; // ok
//	s[0] = 0; // error
	/*
	// 만일 list 에 [] 연산이 된다면 사용자는 아래처럼 코딩하려고 합니다.
	for (int i = 0; i < s.size(); i++)
	{
		s[i] = 0;   // 이 코드의 성능을 생각해 보세요
					// i = 1,2,3,4 ... 일때
	}*/





	// 선택 기준
	// 1. [] 를 사용하고 싶은데, 전방삽입을 할일은 없다. : vector
	// 2. [] 를 사용하고 싶은데, 전방삽입도 필요하다.    : deque
	// 3. [] 필요 없고, 중간 삽입/삭제 작업을 많이 한다. : list

	// 권장 : 대부분의 경우 캐쉬가 있는 환경이라면 vector 권장
	// => 캐쉬까지 고려한다면 대부분의 한경에서 vector 가 최선의 선택입니다.


	std::vector<int> c = { 1,2,3 };

	// 대부분의 멤버 함수이름이 유사하므로 컨테이너를 변경해가면서 성능 테스트 할수 있습니다.
	c.push_back(10);
	int n = c.back();
}




